import 'dart:io';

void main() async {
  final lcovFile = File('coverage/lcov.info');
  if (!await lcovFile.exists()) {
    print('Error: coverage/lcov.info not found.');
    return;
  }

  final lines = await lcovFile.readAsLines();
  final coveredFiles = <String, Map<String, int>>{};
  String? currentFile;

  for (final line in lines) {
    if (line.startsWith('SF:')) {
      currentFile = line.substring(3);
      coveredFiles[currentFile] = {'total': 0, 'hit': 0};
    } else if (line.startsWith('DA:') && currentFile != null) {
      final parts = line.substring(3).split(',');
      final count = int.parse(parts[1]);
      coveredFiles[currentFile]!['total'] =
          coveredFiles[currentFile]!['total']! + 1;
      if (count > 0) {
        coveredFiles[currentFile]!['hit'] =
            coveredFiles[currentFile]!['hit']! + 1;
      }
    }
  }

  print('Comprehensive Coverage Report (Excluding Autogenerated Files):');
  print('------------------------------------------------------------');

  final allLibFiles = Directory('lib')
      .listSync(recursive: true)
      .where((e) => e is File && e.path.endsWith('.dart'))
      .where((e) {
        final path = e.path;
        // Exclude autogenerated patterns
        if (path.contains('.pb.') ||
            path.contains('.pbenum.') ||
            path.contains('.pbjson.') ||
            path.contains('.pbserver.') ||
            path.contains('.g.dart') ||
            path.contains('.freezed.dart') ||
            path.contains('/proto/')) {
          return false;
        }
        return true;
      })
      .map((e) => e.path)
      .toList();

  int totalLines = 0;
  int totalHit = 0;

  Map<String, List<Map<String, dynamic>>> resultsByDir = {};

  for (final relPath in allLibFiles) {
    var stats = coveredFiles[relPath];

    // Sometimes paths in LCOV might be absolute or have different prefixes
    if (stats == null) {
      final absPath = File(relPath).absolute.path;
      stats = coveredFiles[absPath];
    }

    final total = stats?['total'] ?? 0;
    final hit = stats?['hit'] ?? 0;

    // Count files with 0 coverage even if not in LCOV (if they are real source files)
    // However, if the file has 0 lines of executable code (e.g. only exports), it shouldn't count.
    // For simplicity, we'll only count files present in LCOV for the total calculation,
    // but list all non-covered files.
    if (stats != null) {
      totalLines += total;
      totalHit += hit;
    }

    final coverage = total == 0 ? 0.0 : (hit / total * 100);
    final dir = relPath.contains('/')
        ? relPath.substring(0, relPath.lastIndexOf('/'))
        : '.';
    resultsByDir.putIfAbsent(dir, () => []);
    resultsByDir[dir]!.add({
      'path': relPath,
      'coverage': coverage,
      'total': total,
      'hit': hit,
      'isCovered': stats != null,
    });
  }

  final sortedDirs = resultsByDir.keys.toList()..sort();
  for (final dir in sortedDirs) {
    print('\nDirectory: $dir');
    final files = resultsByDir[dir]!;
    files.sort((a, b) => (a['path'] as String).compareTo(b['path'] as String));
    for (final file in files) {
      final coverageStr = (file['coverage'] as double)
          .toStringAsFixed(1)
          .padLeft(6);
      final status = file['isCovered'] ? '' : ' (MISSING DATA)';
      print('[$coverageStr%] ${file['path']}$status');
    }
  }

  print('\n------------------------------------------------------------');
  final totalCoverage = totalLines == 0 ? 0.0 : (totalHit / totalLines * 100);
  print('Summary:');
  print('Total Executable Lines: $totalLines');
  print('Total Lines Hit:        $totalHit');
  print('Overall Coverage:       ${totalCoverage.toStringAsFixed(2)}%');
}
